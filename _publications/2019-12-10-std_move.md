---
title: "std::move"
collection: publications
permalink: /publications/2019-12-10-move
excerpt: 'std::move'
excerpt: "<i>std::move</i><br/>`std` `c++14` `standard library` 
tags:
  - std
  - c++11
  - standard library
  - std::move
---

# Problem

Here I'm back, on my series of C++. Today we're going to be talking about the std::move semantics. This is probably one of the most requested topic.
In this article, I would like to make a introduction, because the basic of std::move is very simple, but then what you can do with it... it could be very complex.


Before to continue this article, I highly recomend that read the my article about the lvalues and rvalues, because this article more or less going to be a continuation of that article.


# The Basics

Move semantics essentially just allow us to move objects around. This wasn't possible before c++11. The c++11 introduced the rvalue references, which are necessery for the move semantics. 
The basic idea is when we are writing a C++ code, there are lot of cases in which we don't really need to or want to necessarily copy an object one place from the other.


For example: 
- If passing an object into a function that then is going to take the ownership of that object, i have no choice to copy it. 
- The same things occur when I want to return an object from a function. I still have to create that object inside that actual function and then return it. Which means that again i'm copyng that data.

![](example.gif)
